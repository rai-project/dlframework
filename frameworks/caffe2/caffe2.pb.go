// Code generated by protoc-gen-gogo.
// source: caffe2.proto
// DO NOT EDIT!

/*
	Package caffe2 is a generated protocol buffer package.

	It is generated from these files:
		caffe2.proto
		caffe2_legacy.proto
		hsm.proto
		metanet.proto
		predictor_consts.proto
		prof_dag.proto

	It has these top-level messages:
		TensorProto
		QTensorProto
		TensorProtos
		TensorShape
		TensorShapes
		Argument
		DeviceOption
		OperatorDef
		NetDef
		ExecutionStep
		PlanDef
		BlobProto
		DBReaderProto
		NodeProto
		TreeProto
		HierarchyProto
		PathProto
		PathNodeProto
		ModelInfo
		BlobsMap
		NetsMap
		PlansMap
		StringMap
		MetaNetDef
		PredictorConsts
		ProfDAGProto
		ProfDAGProtos
*/
package caffe2

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// DeviceType that Caffe2 currently supports.
// Note: if you add a device type, make sure you add the corresponding device
// line in core/blob_serialization.cc.
type DeviceType int32

const (
	DeviceType_CPU           DeviceType = 0
	DeviceType_CUDA          DeviceType = 1
	DeviceType_MKLDNN        DeviceType = 2
	DeviceType_ONLY_FOR_TEST DeviceType = 20901701
)

var DeviceType_name = map[int32]string{
	0:        "CPU",
	1:        "CUDA",
	2:        "MKLDNN",
	20901701: "ONLY_FOR_TEST",
}
var DeviceType_value = map[string]int32{
	"CPU":           0,
	"CUDA":          1,
	"MKLDNN":        2,
	"ONLY_FOR_TEST": 20901701,
}

func (x DeviceType) Enum() *DeviceType {
	p := new(DeviceType)
	*p = x
	return p
}
func (x DeviceType) String() string {
	return proto.EnumName(DeviceType_name, int32(x))
}
func (x *DeviceType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DeviceType_value, data, "DeviceType")
	if err != nil {
		return err
	}
	*x = DeviceType(value)
	return nil
}
func (DeviceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{0} }

type TensorProto_DataType int32

const (
	TensorProto_UNDEFINED TensorProto_DataType = 0
	TensorProto_FLOAT     TensorProto_DataType = 1
	TensorProto_INT32     TensorProto_DataType = 2
	TensorProto_BYTE      TensorProto_DataType = 3
	TensorProto_STRING    TensorProto_DataType = 4
	// Less-commonly used data types.
	TensorProto_BOOL    TensorProto_DataType = 5
	TensorProto_UINT8   TensorProto_DataType = 6
	TensorProto_INT8    TensorProto_DataType = 7
	TensorProto_UINT16  TensorProto_DataType = 8
	TensorProto_INT16   TensorProto_DataType = 9
	TensorProto_INT64   TensorProto_DataType = 10
	TensorProto_FLOAT16 TensorProto_DataType = 12
	TensorProto_DOUBLE  TensorProto_DataType = 13
)

var TensorProto_DataType_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "FLOAT",
	2:  "INT32",
	3:  "BYTE",
	4:  "STRING",
	5:  "BOOL",
	6:  "UINT8",
	7:  "INT8",
	8:  "UINT16",
	9:  "INT16",
	10: "INT64",
	12: "FLOAT16",
	13: "DOUBLE",
}
var TensorProto_DataType_value = map[string]int32{
	"UNDEFINED": 0,
	"FLOAT":     1,
	"INT32":     2,
	"BYTE":      3,
	"STRING":    4,
	"BOOL":      5,
	"UINT8":     6,
	"INT8":      7,
	"UINT16":    8,
	"INT16":     9,
	"INT64":     10,
	"FLOAT16":   12,
	"DOUBLE":    13,
}

func (x TensorProto_DataType) Enum() *TensorProto_DataType {
	p := new(TensorProto_DataType)
	*p = x
	return p
}
func (x TensorProto_DataType) String() string {
	return proto.EnumName(TensorProto_DataType_name, int32(x))
}
func (x *TensorProto_DataType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TensorProto_DataType_value, data, "TensorProto_DataType")
	if err != nil {
		return err
	}
	*x = TensorProto_DataType(value)
	return nil
}
func (TensorProto_DataType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{0, 0} }

// TensorProto stores serialized Tensor objects.
type TensorProto struct {
	// The dimensions in the tensor.
	Dims     []int64               `protobuf:"varint,1,rep,name=dims" json:"dims,omitempty"`
	DataType *TensorProto_DataType `protobuf:"varint,2,opt,name=data_type,json=dataType,enum=caffe2.TensorProto_DataType,def=1" json:"data_type,omitempty"`
	// For float
	FloatData []float32 `protobuf:"fixed32,3,rep,packed,name=float_data,json=floatData" json:"float_data,omitempty"`
	// For int32, uint8, int8, uint16, int16, bool, and float16
	// Note about float16: in storage we will basically convert float16 byte-wise
	// to unsigned short and then store them in the int32_data field.
	Int32Data []int32 `protobuf:"varint,4,rep,packed,name=int32_data,json=int32Data" json:"int32_data,omitempty"`
	// For bytes
	ByteData []byte `protobuf:"bytes,5,opt,name=byte_data,json=byteData" json:"byte_data"`
	// For strings
	StringData [][]byte `protobuf:"bytes,6,rep,name=string_data,json=stringData" json:"string_data,omitempty"`
	// For double
	DoubleData []float64 `protobuf:"fixed64,9,rep,packed,name=double_data,json=doubleData" json:"double_data,omitempty"`
	// For int64
	Int64Data []int64 `protobuf:"varint,10,rep,packed,name=int64_data,json=int64Data" json:"int64_data,omitempty"`
	// Optionally, a name for the tensor.
	Name string `protobuf:"bytes,7,opt,name=name" json:"name"`
	// Optionally, a TensorProto can contain the details about the device that
	// it was serialized from. This is useful in cases like snapshotting a whole
	// workspace in a multi-GPU environment.
	DeviceDetail *DeviceOption        `protobuf:"bytes,8,opt,name=device_detail,json=deviceDetail" json:"device_detail,omitempty"`
	Segment      *TensorProto_Segment `protobuf:"bytes,11,opt,name=segment" json:"segment,omitempty"`
}

func (m *TensorProto) Reset()                    { *m = TensorProto{} }
func (m *TensorProto) String() string            { return proto.CompactTextString(m) }
func (*TensorProto) ProtoMessage()               {}
func (*TensorProto) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{0} }

const Default_TensorProto_DataType TensorProto_DataType = TensorProto_FLOAT

func (m *TensorProto) GetDims() []int64 {
	if m != nil {
		return m.Dims
	}
	return nil
}

func (m *TensorProto) GetDataType() TensorProto_DataType {
	if m != nil && m.DataType != nil {
		return *m.DataType
	}
	return Default_TensorProto_DataType
}

func (m *TensorProto) GetFloatData() []float32 {
	if m != nil {
		return m.FloatData
	}
	return nil
}

func (m *TensorProto) GetInt32Data() []int32 {
	if m != nil {
		return m.Int32Data
	}
	return nil
}

func (m *TensorProto) GetByteData() []byte {
	if m != nil {
		return m.ByteData
	}
	return nil
}

func (m *TensorProto) GetStringData() [][]byte {
	if m != nil {
		return m.StringData
	}
	return nil
}

func (m *TensorProto) GetDoubleData() []float64 {
	if m != nil {
		return m.DoubleData
	}
	return nil
}

func (m *TensorProto) GetInt64Data() []int64 {
	if m != nil {
		return m.Int64Data
	}
	return nil
}

func (m *TensorProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TensorProto) GetDeviceDetail() *DeviceOption {
	if m != nil {
		return m.DeviceDetail
	}
	return nil
}

func (m *TensorProto) GetSegment() *TensorProto_Segment {
	if m != nil {
		return m.Segment
	}
	return nil
}

// When loading from chunks this is going to indicate where to put data in the
// full array. When not used full data must to be present
type TensorProto_Segment struct {
	Begin int64 `protobuf:"varint,1,req,name=begin" json:"begin"`
	End   int64 `protobuf:"varint,2,req,name=end" json:"end"`
}

func (m *TensorProto_Segment) Reset()                    { *m = TensorProto_Segment{} }
func (m *TensorProto_Segment) String() string            { return proto.CompactTextString(m) }
func (*TensorProto_Segment) ProtoMessage()               {}
func (*TensorProto_Segment) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{0, 0} }

func (m *TensorProto_Segment) GetBegin() int64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *TensorProto_Segment) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

type QTensorProto struct {
	Dims      []int64 `protobuf:"varint,1,rep,name=dims" json:"dims,omitempty"`
	Precision int32   `protobuf:"varint,2,req,name=precision" json:"precision"`
	Scale     float64 `protobuf:"fixed64,3,req,name=scale" json:"scale"`
	Bias      float64 `protobuf:"fixed64,4,req,name=bias" json:"bias"`
	IsSigned  bool    `protobuf:"varint,5,req,name=is_signed,json=isSigned" json:"is_signed"`
	Data      []int32 `protobuf:"varint,6,rep,packed,name=data" json:"data,omitempty"`
	Name      string  `protobuf:"bytes,7,opt,name=name" json:"name"`
}

func (m *QTensorProto) Reset()                    { *m = QTensorProto{} }
func (m *QTensorProto) String() string            { return proto.CompactTextString(m) }
func (*QTensorProto) ProtoMessage()               {}
func (*QTensorProto) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{1} }

func (m *QTensorProto) GetDims() []int64 {
	if m != nil {
		return m.Dims
	}
	return nil
}

func (m *QTensorProto) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *QTensorProto) GetScale() float64 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *QTensorProto) GetBias() float64 {
	if m != nil {
		return m.Bias
	}
	return 0
}

func (m *QTensorProto) GetIsSigned() bool {
	if m != nil {
		return m.IsSigned
	}
	return false
}

func (m *QTensorProto) GetData() []int32 {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *QTensorProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// TensorProtos stores multiple TensorProto objects in one single proto. This
// is useful for small tensors; For anything big, consider using a DB for
// storage.
type TensorProtos struct {
	Protos []*TensorProto `protobuf:"bytes,1,rep,name=protos" json:"protos,omitempty"`
}

func (m *TensorProtos) Reset()                    { *m = TensorProtos{} }
func (m *TensorProtos) String() string            { return proto.CompactTextString(m) }
func (*TensorProtos) ProtoMessage()               {}
func (*TensorProtos) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{2} }

func (m *TensorProtos) GetProtos() []*TensorProto {
	if m != nil {
		return m.Protos
	}
	return nil
}

type TensorShape struct {
	Dims         []int64               `protobuf:"varint,1,rep,name=dims" json:"dims,omitempty"`
	DataType     *TensorProto_DataType `protobuf:"varint,2,opt,name=data_type,json=dataType,enum=caffe2.TensorProto_DataType,def=1" json:"data_type,omitempty"`
	UnknownDims  []int32               `protobuf:"varint,3,rep,name=unknown_dims,json=unknownDims" json:"unknown_dims,omitempty"`
	UnknownShape *bool                 `protobuf:"varint,4,opt,name=unknown_shape,json=unknownShape,def=0" json:"unknown_shape,omitempty"`
	Name         string                `protobuf:"bytes,5,opt,name=name" json:"name"`
}

func (m *TensorShape) Reset()                    { *m = TensorShape{} }
func (m *TensorShape) String() string            { return proto.CompactTextString(m) }
func (*TensorShape) ProtoMessage()               {}
func (*TensorShape) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{3} }

const Default_TensorShape_DataType TensorProto_DataType = TensorProto_FLOAT
const Default_TensorShape_UnknownShape bool = false

func (m *TensorShape) GetDims() []int64 {
	if m != nil {
		return m.Dims
	}
	return nil
}

func (m *TensorShape) GetDataType() TensorProto_DataType {
	if m != nil && m.DataType != nil {
		return *m.DataType
	}
	return Default_TensorShape_DataType
}

func (m *TensorShape) GetUnknownDims() []int32 {
	if m != nil {
		return m.UnknownDims
	}
	return nil
}

func (m *TensorShape) GetUnknownShape() bool {
	if m != nil && m.UnknownShape != nil {
		return *m.UnknownShape
	}
	return Default_TensorShape_UnknownShape
}

func (m *TensorShape) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type TensorShapes struct {
	Shapes []*TensorShape `protobuf:"bytes,1,rep,name=shapes" json:"shapes,omitempty"`
}

func (m *TensorShapes) Reset()                    { *m = TensorShapes{} }
func (m *TensorShapes) String() string            { return proto.CompactTextString(m) }
func (*TensorShapes) ProtoMessage()               {}
func (*TensorShapes) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{4} }

func (m *TensorShapes) GetShapes() []*TensorShape {
	if m != nil {
		return m.Shapes
	}
	return nil
}

// A named argument containing either singular float, integer and string
// values, or repeated float, int and string arrays.
type Argument struct {
	Name    string    `protobuf:"bytes,1,opt,name=name" json:"name"`
	F       float32   `protobuf:"fixed32,2,opt,name=f" json:"f"`
	I       int64     `protobuf:"varint,3,opt,name=i" json:"i"`
	S       []byte    `protobuf:"bytes,4,opt,name=s" json:"s"`
	Floats  []float32 `protobuf:"fixed32,5,rep,name=floats" json:"floats,omitempty"`
	Ints    []int64   `protobuf:"varint,6,rep,name=ints" json:"ints,omitempty"`
	Strings [][]byte  `protobuf:"bytes,7,rep,name=strings" json:"strings,omitempty"`
}

func (m *Argument) Reset()                    { *m = Argument{} }
func (m *Argument) String() string            { return proto.CompactTextString(m) }
func (*Argument) ProtoMessage()               {}
func (*Argument) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{5} }

func (m *Argument) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Argument) GetF() float32 {
	if m != nil {
		return m.F
	}
	return 0
}

func (m *Argument) GetI() int64 {
	if m != nil {
		return m.I
	}
	return 0
}

func (m *Argument) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *Argument) GetFloats() []float32 {
	if m != nil {
		return m.Floats
	}
	return nil
}

func (m *Argument) GetInts() []int64 {
	if m != nil {
		return m.Ints
	}
	return nil
}

func (m *Argument) GetStrings() [][]byte {
	if m != nil {
		return m.Strings
	}
	return nil
}

// Device-specific options. We do not distinguish DeviceOption protos for
// different DeviceTypes, so currently all devices share the same DeviceOption
// proto. Fields that are specific to a device type is ignored if the type does
// not match.
type DeviceOption struct {
	// [general] Options that need to be carried out before running the execution.
	// optional DeviceType device_type = 1 [ default = CPU ];
	DeviceType *int32 `protobuf:"varint,1,opt,name=device_type,json=deviceType,def=0" json:"device_type,omitempty"`
	// [CUDA specific] the cuda gpu id.
	CudaGpuId int32 `protobuf:"varint,2,opt,name=cuda_gpu_id,json=cudaGpuId" json:"cuda_gpu_id"`
	// [general] The random seed to start the device random number generator with.
	RandomSeed uint32 `protobuf:"varint,3,opt,name=random_seed,json=randomSeed" json:"random_seed"`
}

func (m *DeviceOption) Reset()                    { *m = DeviceOption{} }
func (m *DeviceOption) String() string            { return proto.CompactTextString(m) }
func (*DeviceOption) ProtoMessage()               {}
func (*DeviceOption) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{6} }

const Default_DeviceOption_DeviceType int32 = 0

func (m *DeviceOption) GetDeviceType() int32 {
	if m != nil && m.DeviceType != nil {
		return *m.DeviceType
	}
	return Default_DeviceOption_DeviceType
}

func (m *DeviceOption) GetCudaGpuId() int32 {
	if m != nil {
		return m.CudaGpuId
	}
	return 0
}

func (m *DeviceOption) GetRandomSeed() uint32 {
	if m != nil {
		return m.RandomSeed
	}
	return 0
}

// Operator Definition.
type OperatorDef struct {
	Input  []string `protobuf:"bytes,1,rep,name=input" json:"input,omitempty"`
	Output []string `protobuf:"bytes,2,rep,name=output" json:"output,omitempty"`
	Name   string   `protobuf:"bytes,3,opt,name=name" json:"name"`
	// the operator type. This is needed to create the object from the operator
	// registry.
	Type string      `protobuf:"bytes,4,opt,name=type" json:"type"`
	Arg  []*Argument `protobuf:"bytes,5,rep,name=arg" json:"arg,omitempty"`
	// The device option that the operator should run under.
	DeviceOption *DeviceOption `protobuf:"bytes,6,opt,name=device_option,json=deviceOption" json:"device_option,omitempty"`
	// Optionally, one can specify an engine when there are multiple
	// implementations available simultaneously for one device type.
	// If one specifies an engine but that engine does not exist in the compiled
	// Caffe2 binary, Caffe2 will fall back to the default engine of that device
	// type.
	Engine string `protobuf:"bytes,7,opt,name=engine" json:"engine"`
	// Additional 'fake' inputs used for expressing control dependencies
	// in the operator graph. This can be used to ensure that an
	// operator does not run until another operator is ready, for e.g.
	// scheduling control. These are not passed as actual inputs to the
	// Operator implementation, and are only used by the Net class for
	// scheduling purposes.
	ControlInput []string `protobuf:"bytes,8,rep,name=control_input,json=controlInput" json:"control_input,omitempty"`
	// is_gradient_op argument is only used as a hint in shape inference
	// and has no runtime significance
	IsGradientOp *bool `protobuf:"varint,9,opt,name=is_gradient_op,json=isGradientOp,def=0" json:"is_gradient_op,omitempty"`
}

func (m *OperatorDef) Reset()                    { *m = OperatorDef{} }
func (m *OperatorDef) String() string            { return proto.CompactTextString(m) }
func (*OperatorDef) ProtoMessage()               {}
func (*OperatorDef) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{7} }

const Default_OperatorDef_IsGradientOp bool = false

func (m *OperatorDef) GetInput() []string {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *OperatorDef) GetOutput() []string {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *OperatorDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OperatorDef) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *OperatorDef) GetArg() []*Argument {
	if m != nil {
		return m.Arg
	}
	return nil
}

func (m *OperatorDef) GetDeviceOption() *DeviceOption {
	if m != nil {
		return m.DeviceOption
	}
	return nil
}

func (m *OperatorDef) GetEngine() string {
	if m != nil {
		return m.Engine
	}
	return ""
}

func (m *OperatorDef) GetControlInput() []string {
	if m != nil {
		return m.ControlInput
	}
	return nil
}

func (m *OperatorDef) GetIsGradientOp() bool {
	if m != nil && m.IsGradientOp != nil {
		return *m.IsGradientOp
	}
	return Default_OperatorDef_IsGradientOp
}

// Network definition.
type NetDef struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// Operators that the network contains.
	// Note: this is not named "operator" because that is a reserved word in C++.
	Op []*OperatorDef `protobuf:"bytes,2,rep,name=op" json:"op,omitempty"`
	// The type of network that the net should be run with. This routes the
	// network instantiation to different execution modes. The default mode,
	// "simple", runs the operators in a sequential way as the original Caffe
	// implementation does.
	Type string `protobuf:"bytes,3,opt,name=type" json:"type"`
	// the number of workers, if the operators in the network is to be carried out
	// in parallel.
	// Note: This is to be deprecated. Using the arg field with "num_workers" as
	// key.
	NumWorkers int32 `protobuf:"varint,4,opt,name=num_workers,json=numWorkers" json:"num_workers"`
	// The device option for the network. If a network has a specific device
	// option and one of its operators does not have it set, we will copy over the
	// device option to the operator. This allows us to basically avoid putting
	// device options at every operator.
	DeviceOption *DeviceOption `protobuf:"bytes,5,opt,name=device_option,json=deviceOption" json:"device_option,omitempty"`
	Arg          []*Argument   `protobuf:"bytes,6,rep,name=arg" json:"arg,omitempty"`
	// Two optional fields to declare external input and output of a net.
	// If these two are set, when a net is created, we will sanity check for
	// every op whether its input is declared (either as an external input,
	// or as an intermediate blob created by one of the ops), and sanity check
	// if all blobs in external_output are produced.
	//
	// In cases of memory optimization, declaring external_input and
	// external_output also ensures that storage of these blobs are persistent:
	// for any blob in external_input and external_output, after a network run
	// finishes, their content are actually the right content. Any intermediate
	// blobs' contents may be overwritten.
	ExternalInput  []string `protobuf:"bytes,7,rep,name=external_input,json=externalInput" json:"external_input,omitempty"`
	ExternalOutput []string `protobuf:"bytes,8,rep,name=external_output,json=externalOutput" json:"external_output,omitempty"`
}

func (m *NetDef) Reset()                    { *m = NetDef{} }
func (m *NetDef) String() string            { return proto.CompactTextString(m) }
func (*NetDef) ProtoMessage()               {}
func (*NetDef) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{8} }

func (m *NetDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetDef) GetOp() []*OperatorDef {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *NetDef) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *NetDef) GetNumWorkers() int32 {
	if m != nil {
		return m.NumWorkers
	}
	return 0
}

func (m *NetDef) GetDeviceOption() *DeviceOption {
	if m != nil {
		return m.DeviceOption
	}
	return nil
}

func (m *NetDef) GetArg() []*Argument {
	if m != nil {
		return m.Arg
	}
	return nil
}

func (m *NetDef) GetExternalInput() []string {
	if m != nil {
		return m.ExternalInput
	}
	return nil
}

func (m *NetDef) GetExternalOutput() []string {
	if m != nil {
		return m.ExternalOutput
	}
	return nil
}

// ExecutionStep is actually a sort-of-hacky way we simulate iteration right
// now.
type ExecutionStep struct {
	// ExecutionStep should either contain a set of substeps, or a set of
	// network names to run in this execution step. They should NOT both be set
	// at the same time.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// An execution step could be recursive, in which it involves a set of
	// substeps.
	Substep []*ExecutionStep `protobuf:"bytes,2,rep,name=substep" json:"substep,omitempty"`
	// Alternatively, an execution step could involve one or more networks.
	// Note that you cannot have both substeps and networks. Choose one.
	// Note that an execution step refers networks by their name. The actual
	// network definition of the same name should be included in the network field
	// of the plan. The reason is that a network object might hold internal states
	// (think of a data layer), so we want to have the same network object that
	// multiple steps could ask to run.
	Network []string `protobuf:"bytes,3,rep,name=network" json:"network,omitempty"`
	// Number of iterations to run this step. The substeps or the networks
	// specified will be run sequentially, and one sequential run is considered
	// one iteration. If this is not set, the number of iterations is assumed to
	// be 1.
	NumIter int64 `protobuf:"varint,4,opt,name=num_iter,json=numIter" json:"num_iter"`
	// Criteria network specifies a single output (TensorCPU<bool>) of
	// size (1), is run on every iteration by the executor, and
	// execution terminates when the output[0] is `false`.
	CriteriaNetwork string `protobuf:"bytes,5,opt,name=criteria_network,json=criteriaNetwork" json:"criteria_network"`
	// DEPRECATED. Use `run_every_ms`.
	ReportNet      string `protobuf:"bytes,7,opt,name=report_net,json=reportNet" json:"report_net"`
	ReportInterval int32  `protobuf:"varint,8,opt,name=report_interval,json=reportInterval" json:"report_interval"`
	// If provided, execute this step at every time interval (in millisecs)
	// while its sibiling execution steps execute in parallel. This step is
	// guaranteed to run at least once after all non-interval siblings finished.
	RunEveryMs int64 `protobuf:"varint,11,opt,name=run_every_ms,json=runEveryMs" json:"run_every_ms"`
	// If false or not set, execute sub-steps serially.
	// If true, execute all substeps concurrently, each one in a separte thread.
	ConcurrentSubsteps bool `protobuf:"varint,6,opt,name=concurrent_substeps,json=concurrentSubsteps" json:"concurrent_substeps"`
	// Name of a scalar boolean tensor.
	// ES checks this blob AFTER every substeps/subnets.
	// If specified, and the value is true, then ES will skip the rest and return
	// immediately.
	// This means that the report_net and the first step will always be called.
	// Use cases:
	// 1) the first substep stops the rest if data condition not met
	// 2) the first substep decide which of the rest of the steps should be run.
	// 3) external control
	//
	// ** It is the user's responsibility to not to put this blob in race conditions.
	// ** For example when setting this blob in concurrent substeps
	ShouldStopBlob string `protobuf:"bytes,9,opt,name=should_stop_blob,json=shouldStopBlob" json:"should_stop_blob"`
	// if only_once is true, this step will only be executed once. this ONLY takes
	// effect when using should_stop_blob
	OnlyOnce bool `protobuf:"varint,10,opt,name=only_once,json=onlyOnce" json:"only_once"`
}

func (m *ExecutionStep) Reset()                    { *m = ExecutionStep{} }
func (m *ExecutionStep) String() string            { return proto.CompactTextString(m) }
func (*ExecutionStep) ProtoMessage()               {}
func (*ExecutionStep) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{9} }

func (m *ExecutionStep) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExecutionStep) GetSubstep() []*ExecutionStep {
	if m != nil {
		return m.Substep
	}
	return nil
}

func (m *ExecutionStep) GetNetwork() []string {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *ExecutionStep) GetNumIter() int64 {
	if m != nil {
		return m.NumIter
	}
	return 0
}

func (m *ExecutionStep) GetCriteriaNetwork() string {
	if m != nil {
		return m.CriteriaNetwork
	}
	return ""
}

func (m *ExecutionStep) GetReportNet() string {
	if m != nil {
		return m.ReportNet
	}
	return ""
}

func (m *ExecutionStep) GetReportInterval() int32 {
	if m != nil {
		return m.ReportInterval
	}
	return 0
}

func (m *ExecutionStep) GetRunEveryMs() int64 {
	if m != nil {
		return m.RunEveryMs
	}
	return 0
}

func (m *ExecutionStep) GetConcurrentSubsteps() bool {
	if m != nil {
		return m.ConcurrentSubsteps
	}
	return false
}

func (m *ExecutionStep) GetShouldStopBlob() string {
	if m != nil {
		return m.ShouldStopBlob
	}
	return ""
}

func (m *ExecutionStep) GetOnlyOnce() bool {
	if m != nil {
		return m.OnlyOnce
	}
	return false
}

type PlanDef struct {
	// All the networks that are used in this execution. Note that networks should
	// be ordered in the way they are executed, i.e. for a layer in a network, all
	// its input blobs should already have been initialized by the layers or
	// networks defined before it.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// The networks that are going to be used in this plan.
	Network       []*NetDef        `protobuf:"bytes,2,rep,name=network" json:"network,omitempty"`
	ExecutionStep []*ExecutionStep `protobuf:"bytes,3,rep,name=execution_step,json=executionStep" json:"execution_step,omitempty"`
}

func (m *PlanDef) Reset()                    { *m = PlanDef{} }
func (m *PlanDef) String() string            { return proto.CompactTextString(m) }
func (*PlanDef) ProtoMessage()               {}
func (*PlanDef) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{10} }

func (m *PlanDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PlanDef) GetNetwork() []*NetDef {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *PlanDef) GetExecutionStep() []*ExecutionStep {
	if m != nil {
		return m.ExecutionStep
	}
	return nil
}

// Protobuf format for blobs that are not Tensors. We use a key to store the
// type of the blob. For example for a serialized DBProto, the type should
// be "DBReader" and the content should be a serialized DBProto object.
type BlobProto struct {
	Name    string        `protobuf:"bytes,1,opt,name=name" json:"name"`
	Type    string        `protobuf:"bytes,2,opt,name=type" json:"type"`
	Tensor  *TensorProto  `protobuf:"bytes,3,opt,name=tensor" json:"tensor,omitempty"`
	Content []byte        `protobuf:"bytes,4,opt,name=content" json:"content"`
	Qtensor *QTensorProto `protobuf:"bytes,5,opt,name=qtensor" json:"qtensor,omitempty"`
}

func (m *BlobProto) Reset()                    { *m = BlobProto{} }
func (m *BlobProto) String() string            { return proto.CompactTextString(m) }
func (*BlobProto) ProtoMessage()               {}
func (*BlobProto) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{11} }

func (m *BlobProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BlobProto) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *BlobProto) GetTensor() *TensorProto {
	if m != nil {
		return m.Tensor
	}
	return nil
}

func (m *BlobProto) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *BlobProto) GetQtensor() *QTensorProto {
	if m != nil {
		return m.Qtensor
	}
	return nil
}

// Protobuf format to serialize DBReader.
type DBReaderProto struct {
	// The name for the DB object in the workspace.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// The source of the DB
	Source string `protobuf:"bytes,2,opt,name=source" json:"source"`
	// The type of the DB
	DbType string `protobuf:"bytes,3,opt,name=db_type,json=dbType" json:"db_type"`
	// The current key of the DB if the DB supports seeking.
	Key string `protobuf:"bytes,4,opt,name=key" json:"key"`
}

func (m *DBReaderProto) Reset()                    { *m = DBReaderProto{} }
func (m *DBReaderProto) String() string            { return proto.CompactTextString(m) }
func (*DBReaderProto) ProtoMessage()               {}
func (*DBReaderProto) Descriptor() ([]byte, []int) { return fileDescriptorCaffe2, []int{12} }

func (m *DBReaderProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DBReaderProto) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *DBReaderProto) GetDbType() string {
	if m != nil {
		return m.DbType
	}
	return ""
}

func (m *DBReaderProto) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func init() {
	proto.RegisterType((*TensorProto)(nil), "caffe2.TensorProto")
	proto.RegisterType((*TensorProto_Segment)(nil), "caffe2.TensorProto.Segment")
	proto.RegisterType((*QTensorProto)(nil), "caffe2.QTensorProto")
	proto.RegisterType((*TensorProtos)(nil), "caffe2.TensorProtos")
	proto.RegisterType((*TensorShape)(nil), "caffe2.TensorShape")
	proto.RegisterType((*TensorShapes)(nil), "caffe2.TensorShapes")
	proto.RegisterType((*Argument)(nil), "caffe2.Argument")
	proto.RegisterType((*DeviceOption)(nil), "caffe2.DeviceOption")
	proto.RegisterType((*OperatorDef)(nil), "caffe2.OperatorDef")
	proto.RegisterType((*NetDef)(nil), "caffe2.NetDef")
	proto.RegisterType((*ExecutionStep)(nil), "caffe2.ExecutionStep")
	proto.RegisterType((*PlanDef)(nil), "caffe2.PlanDef")
	proto.RegisterType((*BlobProto)(nil), "caffe2.BlobProto")
	proto.RegisterType((*DBReaderProto)(nil), "caffe2.DBReaderProto")
	proto.RegisterEnum("caffe2.DeviceType", DeviceType_name, DeviceType_value)
	proto.RegisterEnum("caffe2.TensorProto_DataType", TensorProto_DataType_name, TensorProto_DataType_value)
}
func (m *TensorProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dims) > 0 {
		for _, num := range m.Dims {
			dAtA[i] = 0x8
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(num))
		}
	}
	if m.DataType != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(*m.DataType))
	}
	if len(m.FloatData) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(len(m.FloatData)*4))
		for _, num := range m.FloatData {
			f1 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f1)
			i++
			dAtA[i] = uint8(f1 >> 8)
			i++
			dAtA[i] = uint8(f1 >> 16)
			i++
			dAtA[i] = uint8(f1 >> 24)
			i++
		}
	}
	if len(m.Int32Data) > 0 {
		dAtA3 := make([]byte, len(m.Int32Data)*10)
		var j2 int
		for _, num1 := range m.Int32Data {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.ByteData != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(len(m.ByteData)))
		i += copy(dAtA[i:], m.ByteData)
	}
	if len(m.StringData) > 0 {
		for _, b := range m.StringData {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.DeviceDetail != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(m.DeviceDetail.Size()))
		n4, err := m.DeviceDetail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.DoubleData) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(len(m.DoubleData)*8))
		for _, num := range m.DoubleData {
			f5 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f5)
			i++
			dAtA[i] = uint8(f5 >> 8)
			i++
			dAtA[i] = uint8(f5 >> 16)
			i++
			dAtA[i] = uint8(f5 >> 24)
			i++
			dAtA[i] = uint8(f5 >> 32)
			i++
			dAtA[i] = uint8(f5 >> 40)
			i++
			dAtA[i] = uint8(f5 >> 48)
			i++
			dAtA[i] = uint8(f5 >> 56)
			i++
		}
	}
	if len(m.Int64Data) > 0 {
		dAtA7 := make([]byte, len(m.Int64Data)*10)
		var j6 int
		for _, num1 := range m.Int64Data {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.Segment != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(m.Segment.Size()))
		n8, err := m.Segment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *TensorProto_Segment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorProto_Segment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(m.Begin))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(m.End))
	return i, nil
}

func (m *QTensorProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QTensorProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dims) > 0 {
		for _, num := range m.Dims {
			dAtA[i] = 0x8
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(m.Precision))
	dAtA[i] = 0x19
	i++
	i = encodeFixed64Caffe2(dAtA, i, uint64(math.Float64bits(float64(m.Scale))))
	dAtA[i] = 0x21
	i++
	i = encodeFixed64Caffe2(dAtA, i, uint64(math.Float64bits(float64(m.Bias))))
	dAtA[i] = 0x28
	i++
	if m.IsSigned {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Data) > 0 {
		dAtA10 := make([]byte, len(m.Data)*10)
		var j9 int
		for _, num1 := range m.Data {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}

func (m *TensorProtos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorProtos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Protos) > 0 {
		for _, msg := range m.Protos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TensorShape) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorShape) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dims) > 0 {
		for _, num := range m.Dims {
			dAtA[i] = 0x8
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(num))
		}
	}
	if m.DataType != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(*m.DataType))
	}
	if len(m.UnknownDims) > 0 {
		for _, num := range m.UnknownDims {
			dAtA[i] = 0x18
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(num))
		}
	}
	if m.UnknownShape != nil {
		dAtA[i] = 0x20
		i++
		if *m.UnknownShape {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}

func (m *TensorShapes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorShapes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Shapes) > 0 {
		for _, msg := range m.Shapes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Argument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Argument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x15
	i++
	i = encodeFixed32Caffe2(dAtA, i, uint32(math.Float32bits(float32(m.F))))
	dAtA[i] = 0x18
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(m.I))
	if m.S != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(len(m.S)))
		i += copy(dAtA[i:], m.S)
	}
	if len(m.Floats) > 0 {
		for _, num := range m.Floats {
			dAtA[i] = 0x2d
			i++
			f11 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f11)
			i++
			dAtA[i] = uint8(f11 >> 8)
			i++
			dAtA[i] = uint8(f11 >> 16)
			i++
			dAtA[i] = uint8(f11 >> 24)
			i++
		}
	}
	if len(m.Ints) > 0 {
		for _, num := range m.Ints {
			dAtA[i] = 0x30
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(num))
		}
	}
	if len(m.Strings) > 0 {
		for _, b := range m.Strings {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *DeviceOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DeviceType != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(*m.DeviceType))
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(m.CudaGpuId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(m.RandomSeed))
	return i, nil
}

func (m *OperatorDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Input) > 0 {
		for _, s := range m.Input {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Output) > 0 {
		for _, s := range m.Output {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Type)))
	i += copy(dAtA[i:], m.Type)
	if len(m.Arg) > 0 {
		for _, msg := range m.Arg {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DeviceOption != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(m.DeviceOption.Size()))
		n12, err := m.DeviceOption.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Engine)))
	i += copy(dAtA[i:], m.Engine)
	if len(m.ControlInput) > 0 {
		for _, s := range m.ControlInput {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IsGradientOp != nil {
		dAtA[i] = 0x48
		i++
		if *m.IsGradientOp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *NetDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.Op) > 0 {
		for _, msg := range m.Op {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Type)))
	i += copy(dAtA[i:], m.Type)
	dAtA[i] = 0x20
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(m.NumWorkers))
	if m.DeviceOption != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(m.DeviceOption.Size()))
		n13, err := m.DeviceOption.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Arg) > 0 {
		for _, msg := range m.Arg {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ExternalInput) > 0 {
		for _, s := range m.ExternalInput {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExternalOutput) > 0 {
		for _, s := range m.ExternalOutput {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ExecutionStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionStep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.Substep) > 0 {
		for _, msg := range m.Substep {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Network) > 0 {
		for _, s := range m.Network {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(m.NumIter))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.CriteriaNetwork)))
	i += copy(dAtA[i:], m.CriteriaNetwork)
	dAtA[i] = 0x30
	i++
	if m.ConcurrentSubsteps {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x3a
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.ReportNet)))
	i += copy(dAtA[i:], m.ReportNet)
	dAtA[i] = 0x40
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(m.ReportInterval))
	dAtA[i] = 0x4a
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.ShouldStopBlob)))
	i += copy(dAtA[i:], m.ShouldStopBlob)
	dAtA[i] = 0x50
	i++
	if m.OnlyOnce {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x58
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(m.RunEveryMs))
	return i, nil
}

func (m *PlanDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.Network) > 0 {
		for _, msg := range m.Network {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ExecutionStep) > 0 {
		for _, msg := range m.ExecutionStep {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCaffe2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BlobProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Type)))
	i += copy(dAtA[i:], m.Type)
	if m.Tensor != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(m.Tensor.Size()))
		n14, err := m.Tensor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Content != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Qtensor != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCaffe2(dAtA, i, uint64(m.Qtensor.Size()))
		n15, err := m.Qtensor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *DBReaderProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DBReaderProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Source)))
	i += copy(dAtA[i:], m.Source)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.DbType)))
	i += copy(dAtA[i:], m.DbType)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCaffe2(dAtA, i, uint64(len(m.Key)))
	i += copy(dAtA[i:], m.Key)
	return i, nil
}

func encodeFixed64Caffe2(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Caffe2(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCaffe2(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TensorProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Dims) > 0 {
		for _, e := range m.Dims {
			n += 1 + sovCaffe2(uint64(e))
		}
	}
	if m.DataType != nil {
		n += 1 + sovCaffe2(uint64(*m.DataType))
	}
	if len(m.FloatData) > 0 {
		n += 1 + sovCaffe2(uint64(len(m.FloatData)*4)) + len(m.FloatData)*4
	}
	if len(m.Int32Data) > 0 {
		l = 0
		for _, e := range m.Int32Data {
			l += sovCaffe2(uint64(e))
		}
		n += 1 + sovCaffe2(uint64(l)) + l
	}
	if m.ByteData != nil {
		l = len(m.ByteData)
		n += 1 + l + sovCaffe2(uint64(l))
	}
	if len(m.StringData) > 0 {
		for _, b := range m.StringData {
			l = len(b)
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	l = len(m.Name)
	n += 1 + l + sovCaffe2(uint64(l))
	if m.DeviceDetail != nil {
		l = m.DeviceDetail.Size()
		n += 1 + l + sovCaffe2(uint64(l))
	}
	if len(m.DoubleData) > 0 {
		n += 1 + sovCaffe2(uint64(len(m.DoubleData)*8)) + len(m.DoubleData)*8
	}
	if len(m.Int64Data) > 0 {
		l = 0
		for _, e := range m.Int64Data {
			l += sovCaffe2(uint64(e))
		}
		n += 1 + sovCaffe2(uint64(l)) + l
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovCaffe2(uint64(l))
	}
	return n
}

func (m *TensorProto_Segment) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovCaffe2(uint64(m.Begin))
	n += 1 + sovCaffe2(uint64(m.End))
	return n
}

func (m *QTensorProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Dims) > 0 {
		for _, e := range m.Dims {
			n += 1 + sovCaffe2(uint64(e))
		}
	}
	n += 1 + sovCaffe2(uint64(m.Precision))
	n += 9
	n += 9
	n += 2
	if len(m.Data) > 0 {
		l = 0
		for _, e := range m.Data {
			l += sovCaffe2(uint64(e))
		}
		n += 1 + sovCaffe2(uint64(l)) + l
	}
	l = len(m.Name)
	n += 1 + l + sovCaffe2(uint64(l))
	return n
}

func (m *TensorProtos) Size() (n int) {
	var l int
	_ = l
	if len(m.Protos) > 0 {
		for _, e := range m.Protos {
			l = e.Size()
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	return n
}

func (m *TensorShape) Size() (n int) {
	var l int
	_ = l
	if len(m.Dims) > 0 {
		for _, e := range m.Dims {
			n += 1 + sovCaffe2(uint64(e))
		}
	}
	if m.DataType != nil {
		n += 1 + sovCaffe2(uint64(*m.DataType))
	}
	if len(m.UnknownDims) > 0 {
		for _, e := range m.UnknownDims {
			n += 1 + sovCaffe2(uint64(e))
		}
	}
	if m.UnknownShape != nil {
		n += 2
	}
	l = len(m.Name)
	n += 1 + l + sovCaffe2(uint64(l))
	return n
}

func (m *TensorShapes) Size() (n int) {
	var l int
	_ = l
	if len(m.Shapes) > 0 {
		for _, e := range m.Shapes {
			l = e.Size()
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	return n
}

func (m *Argument) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCaffe2(uint64(l))
	n += 5
	n += 1 + sovCaffe2(uint64(m.I))
	if m.S != nil {
		l = len(m.S)
		n += 1 + l + sovCaffe2(uint64(l))
	}
	if len(m.Floats) > 0 {
		n += 5 * len(m.Floats)
	}
	if len(m.Ints) > 0 {
		for _, e := range m.Ints {
			n += 1 + sovCaffe2(uint64(e))
		}
	}
	if len(m.Strings) > 0 {
		for _, b := range m.Strings {
			l = len(b)
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	return n
}

func (m *DeviceOption) Size() (n int) {
	var l int
	_ = l
	if m.DeviceType != nil {
		n += 1 + sovCaffe2(uint64(*m.DeviceType))
	}
	n += 1 + sovCaffe2(uint64(m.CudaGpuId))
	n += 1 + sovCaffe2(uint64(m.RandomSeed))
	return n
}

func (m *OperatorDef) Size() (n int) {
	var l int
	_ = l
	if len(m.Input) > 0 {
		for _, s := range m.Input {
			l = len(s)
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	if len(m.Output) > 0 {
		for _, s := range m.Output {
			l = len(s)
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	l = len(m.Name)
	n += 1 + l + sovCaffe2(uint64(l))
	l = len(m.Type)
	n += 1 + l + sovCaffe2(uint64(l))
	if len(m.Arg) > 0 {
		for _, e := range m.Arg {
			l = e.Size()
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	if m.DeviceOption != nil {
		l = m.DeviceOption.Size()
		n += 1 + l + sovCaffe2(uint64(l))
	}
	l = len(m.Engine)
	n += 1 + l + sovCaffe2(uint64(l))
	if len(m.ControlInput) > 0 {
		for _, s := range m.ControlInput {
			l = len(s)
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	if m.IsGradientOp != nil {
		n += 2
	}
	return n
}

func (m *NetDef) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCaffe2(uint64(l))
	if len(m.Op) > 0 {
		for _, e := range m.Op {
			l = e.Size()
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	l = len(m.Type)
	n += 1 + l + sovCaffe2(uint64(l))
	n += 1 + sovCaffe2(uint64(m.NumWorkers))
	if m.DeviceOption != nil {
		l = m.DeviceOption.Size()
		n += 1 + l + sovCaffe2(uint64(l))
	}
	if len(m.Arg) > 0 {
		for _, e := range m.Arg {
			l = e.Size()
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	if len(m.ExternalInput) > 0 {
		for _, s := range m.ExternalInput {
			l = len(s)
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	if len(m.ExternalOutput) > 0 {
		for _, s := range m.ExternalOutput {
			l = len(s)
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	return n
}

func (m *ExecutionStep) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCaffe2(uint64(l))
	if len(m.Substep) > 0 {
		for _, e := range m.Substep {
			l = e.Size()
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	if len(m.Network) > 0 {
		for _, s := range m.Network {
			l = len(s)
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	n += 1 + sovCaffe2(uint64(m.NumIter))
	l = len(m.CriteriaNetwork)
	n += 1 + l + sovCaffe2(uint64(l))
	n += 2
	l = len(m.ReportNet)
	n += 1 + l + sovCaffe2(uint64(l))
	n += 1 + sovCaffe2(uint64(m.ReportInterval))
	l = len(m.ShouldStopBlob)
	n += 1 + l + sovCaffe2(uint64(l))
	n += 2
	n += 1 + sovCaffe2(uint64(m.RunEveryMs))
	return n
}

func (m *PlanDef) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCaffe2(uint64(l))
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	if len(m.ExecutionStep) > 0 {
		for _, e := range m.ExecutionStep {
			l = e.Size()
			n += 1 + l + sovCaffe2(uint64(l))
		}
	}
	return n
}

func (m *BlobProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCaffe2(uint64(l))
	l = len(m.Type)
	n += 1 + l + sovCaffe2(uint64(l))
	if m.Tensor != nil {
		l = m.Tensor.Size()
		n += 1 + l + sovCaffe2(uint64(l))
	}
	if m.Content != nil {
		l = len(m.Content)
		n += 1 + l + sovCaffe2(uint64(l))
	}
	if m.Qtensor != nil {
		l = m.Qtensor.Size()
		n += 1 + l + sovCaffe2(uint64(l))
	}
	return n
}

func (m *DBReaderProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCaffe2(uint64(l))
	l = len(m.Source)
	n += 1 + l + sovCaffe2(uint64(l))
	l = len(m.DbType)
	n += 1 + l + sovCaffe2(uint64(l))
	l = len(m.Key)
	n += 1 + l + sovCaffe2(uint64(l))
	return n
}

func sovCaffe2(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCaffe2(x uint64) (n int) {
	return sovCaffe2(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TensorProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dims = append(m.Dims, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dims = append(m.Dims, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dims", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			var v TensorProto_DataType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TensorProto_DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DataType = &v
		case 3:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.FloatData = append(m.FloatData, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.FloatData = append(m.FloatData, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatData", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Int32Data = append(m.Int32Data, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Int32Data = append(m.Int32Data, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32Data", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteData = append(m.ByteData[:0], dAtA[iNdEx:postIndex]...)
			if m.ByteData == nil {
				m.ByteData = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringData = append(m.StringData, make([]byte, postIndex-iNdEx))
			copy(m.StringData[len(m.StringData)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceDetail == nil {
				m.DeviceDetail = &DeviceOption{}
			}
			if err := m.DeviceDetail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.DoubleData = append(m.DoubleData, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.DoubleData = append(m.DoubleData, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleData", wireType)
			}
		case 10:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Int64Data = append(m.Int64Data, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Int64Data = append(m.Int64Data, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Data", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &TensorProto_Segment{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorProto_Segment) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Segment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Segment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("begin")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("end")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QTensorProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QTensorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QTensorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dims = append(m.Dims, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dims = append(m.Dims, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dims", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Scale = float64(math.Float64frombits(v))
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bias", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Bias = float64(math.Float64frombits(v))
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSigned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSigned = bool(v != 0)
			hasFields[0] |= uint64(0x00000008)
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Data = append(m.Data, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Data = append(m.Data, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("precision")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("scale")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("bias")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("is_signed")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorProtos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorProtos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorProtos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protos = append(m.Protos, &TensorProto{})
			if err := m.Protos[len(m.Protos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorShape) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorShape: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorShape: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dims = append(m.Dims, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dims = append(m.Dims, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dims", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			var v TensorProto_DataType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TensorProto_DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DataType = &v
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnknownDims = append(m.UnknownDims, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnknownDims = append(m.UnknownDims, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnknownDims", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnknownShape", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UnknownShape = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorShapes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorShapes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorShapes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shapes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shapes = append(m.Shapes, &TensorShape{})
			if err := m.Shapes[len(m.Shapes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Argument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Argument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Argument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.F = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I", wireType)
			}
			m.I = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.I |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = append(m.S[:0], dAtA[iNdEx:postIndex]...)
			if m.S == nil {
				m.S = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Floats = append(m.Floats, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Floats = append(m.Floats, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Floats", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ints = append(m.Ints, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ints = append(m.Ints, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ints", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, make([]byte, postIndex-iNdEx))
			copy(m.Strings[len(m.Strings)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeviceType = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CudaGpuId", wireType)
			}
			m.CudaGpuId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CudaGpuId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSeed", wireType)
			}
			m.RandomSeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomSeed |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = append(m.Input, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = append(m.Output, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arg = append(m.Arg, &Argument{})
			if err := m.Arg[len(m.Arg)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceOption == nil {
				m.DeviceOption = &DeviceOption{}
			}
			if err := m.DeviceOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Engine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlInput", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlInput = append(m.ControlInput, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGradientOp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsGradientOp = &b
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = append(m.Op, &OperatorDef{})
			if err := m.Op[len(m.Op)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumWorkers", wireType)
			}
			m.NumWorkers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumWorkers |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceOption == nil {
				m.DeviceOption = &DeviceOption{}
			}
			if err := m.DeviceOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arg = append(m.Arg, &Argument{})
			if err := m.Arg[len(m.Arg)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalInput", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalInput = append(m.ExternalInput, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalOutput", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalOutput = append(m.ExternalOutput, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Substep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Substep = append(m.Substep, &ExecutionStep{})
			if err := m.Substep[len(m.Substep)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumIter", wireType)
			}
			m.NumIter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumIter |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CriteriaNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CriteriaNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcurrentSubsteps", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConcurrentSubsteps = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportNet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportNet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportInterval", wireType)
			}
			m.ReportInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportInterval |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShouldStopBlob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShouldStopBlob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyOnce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyOnce = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunEveryMs", wireType)
			}
			m.RunEveryMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunEveryMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &NetDef{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionStep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionStep = append(m.ExecutionStep, &ExecutionStep{})
			if err := m.ExecutionStep[len(m.ExecutionStep)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tensor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tensor == nil {
				m.Tensor = &TensorProto{}
			}
			if err := m.Tensor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qtensor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Qtensor == nil {
				m.Qtensor = &QTensorProto{}
			}
			if err := m.Qtensor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DBReaderProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DBReaderProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DBReaderProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCaffe2(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCaffe2
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaffe2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCaffe2
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCaffe2
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCaffe2(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCaffe2 = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCaffe2   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("caffe2.proto", fileDescriptorCaffe2) }

var fileDescriptorCaffe2 = []byte{
	// 1440 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xdd, 0x6e, 0xdb, 0x46,
	0x16, 0x36, 0x49, 0x51, 0x14, 0x8f, 0x24, 0x87, 0x98, 0x64, 0x0d, 0x22, 0x9b, 0x75, 0xb4, 0xf4,
	0x66, 0x23, 0x24, 0x58, 0xef, 0xda, 0x49, 0x8c, 0x6d, 0xda, 0x02, 0xb5, 0x22, 0x27, 0x10, 0xea,
	0x48, 0x29, 0x25, 0xa3, 0xc8, 0x15, 0x41, 0x89, 0x63, 0x85, 0x88, 0x34, 0x64, 0x39, 0xc3, 0x24,
	0xbe, 0x69, 0x1f, 0xa0, 0x37, 0x7d, 0x83, 0x02, 0xbd, 0xe8, 0x3b, 0x14, 0x28, 0x7a, 0x57, 0x20,
	0x17, 0x45, 0xd1, 0xbe, 0x40, 0x50, 0xa4, 0x8f, 0xd1, 0x9b, 0x62, 0xfe, 0x64, 0xb9, 0x8e, 0x9d,
	0xde, 0xf4, 0x8e, 0xf3, 0x9d, 0x8f, 0x33, 0xe7, 0x7c, 0xe7, 0x67, 0x06, 0x1a, 0x93, 0xf8, 0xf0,
	0x10, 0x6f, 0x6f, 0xe6, 0x45, 0xc6, 0x32, 0x54, 0x95, 0xab, 0xe0, 0x2b, 0x1b, 0xea, 0x23, 0x4c,
	0x68, 0x56, 0x3c, 0x12, 0x38, 0x82, 0x4a, 0x92, 0xce, 0xa9, 0x6f, 0xb4, 0xac, 0xb6, 0x15, 0x8a,
	0x6f, 0xf4, 0x01, 0xb8, 0x49, 0xcc, 0xe2, 0x88, 0x1d, 0xe5, 0xd8, 0x37, 0x5b, 0x46, 0x7b, 0x75,
	0xfb, 0xca, 0xa6, 0xda, 0x6d, 0xe9, 0xdf, 0xcd, 0x6e, 0xcc, 0xe2, 0xd1, 0x51, 0x8e, 0xef, 0xda,
	0xf7, 0xf7, 0x07, 0xbb, 0xa3, 0xb0, 0x96, 0x28, 0x00, 0xfd, 0x13, 0xe0, 0x70, 0x96, 0xc5, 0x2c,
	0xe2, 0x88, 0x6f, 0xb5, 0xac, 0xb6, 0xd9, 0x31, 0x3d, 0x23, 0x74, 0x05, 0xca, 0xff, 0xe3, 0x94,
	0x94, 0xb0, 0x5b, 0xdb, 0x92, 0x52, 0x69, 0x59, 0x6d, 0x5b, 0x52, 0x04, 0xaa, 0x28, 0xee, 0xf8,
	0x88, 0x61, 0xc9, 0xb0, 0x5b, 0x46, 0xbb, 0xd1, 0xa9, 0xbc, 0x7c, 0x75, 0x75, 0x25, 0xac, 0x71,
	0x58, 0x50, 0xae, 0x42, 0x9d, 0xb2, 0x22, 0x25, 0x53, 0x49, 0xaa, 0xb6, 0xac, 0x76, 0x23, 0x04,
	0x09, 0x09, 0x82, 0x0f, 0x15, 0x12, 0xcf, 0xb1, 0xef, 0xb4, 0x8c, 0xb6, 0xab, 0x7e, 0x17, 0x08,
	0x7a, 0x07, 0x9a, 0x09, 0x7e, 0x96, 0x4e, 0x70, 0x94, 0x60, 0x16, 0xa7, 0x33, 0xbf, 0xd6, 0x32,
	0xda, 0xf5, 0xed, 0x4b, 0x3a, 0xd2, 0xae, 0x30, 0x0e, 0x72, 0x96, 0x66, 0x24, 0x6c, 0x48, 0x6a,
	0x57, 0x30, 0xd1, 0x06, 0xd4, 0x93, 0xac, 0x1c, 0xcf, 0x94, 0x6b, 0x6e, 0xcb, 0x6a, 0x1b, 0xc2,
	0x79, 0x90, 0xf0, 0x52, 0x80, 0x3b, 0xb7, 0x25, 0x07, 0xb8, 0xbe, 0x8b, 0x00, 0x77, 0x6e, 0x0b,
	0xca, 0x1d, 0x70, 0x28, 0x9e, 0xce, 0x31, 0x61, 0x7e, 0x5d, 0x1c, 0xfe, 0xf7, 0x37, 0xc9, 0x3c,
	0x94, 0x94, 0x50, 0x73, 0x2f, 0xbf, 0x0f, 0x8e, 0xc2, 0xd0, 0x65, 0xb0, 0xc7, 0x78, 0x9a, 0x12,
	0xdf, 0x68, 0x99, 0x6d, 0x4b, 0xc5, 0x27, 0x21, 0xb4, 0x06, 0x16, 0x26, 0x89, 0x6f, 0x2e, 0x59,
	0x38, 0x10, 0x7c, 0x69, 0x40, 0x4d, 0xa7, 0x0e, 0x35, 0xc1, 0x3d, 0xe8, 0x77, 0xf7, 0xee, 0xf7,
	0xfa, 0x7b, 0x5d, 0x6f, 0x05, 0xb9, 0x20, 0x73, 0xe9, 0x19, 0xfc, 0xb3, 0xd7, 0x1f, 0xdd, 0xda,
	0xf6, 0x4c, 0x54, 0x83, 0x4a, 0xe7, 0xf1, 0x68, 0xcf, 0xb3, 0x10, 0x40, 0x75, 0x38, 0x0a, 0x7b,
	0xfd, 0x07, 0x5e, 0x45, 0xa0, 0x83, 0xc1, 0xbe, 0x67, 0x73, 0xea, 0x41, 0xaf, 0x3f, 0xfa, 0xbf,
	0x57, 0xe5, 0xa0, 0xf8, 0x72, 0x38, 0x95, 0x83, 0x5b, 0x3b, 0x5e, 0x4d, 0xed, 0xb5, 0xb5, 0xe3,
	0xb9, 0xea, 0x73, 0xe7, 0xb6, 0x07, 0xa8, 0x0e, 0x8e, 0x38, 0x6c, 0x6b, 0xc7, 0x6b, 0x70, 0x7a,
	0x77, 0x70, 0xd0, 0xd9, 0xdf, 0xf3, 0x9a, 0xc1, 0xcf, 0x06, 0x34, 0x3e, 0x7a, 0x5b, 0x95, 0x06,
	0xe0, 0xe6, 0x05, 0x9e, 0xa4, 0x34, 0xcd, 0x88, 0x08, 0xd2, 0x56, 0x41, 0x1e, 0xc3, 0x5c, 0x1e,
	0x3a, 0x89, 0x67, 0xd8, 0xb7, 0x5a, 0x66, 0xdb, 0xd0, 0xf2, 0x08, 0x88, 0x57, 0xc6, 0x38, 0x8d,
	0xa9, 0x5f, 0x59, 0x32, 0x09, 0x84, 0xd7, 0x5d, 0x4a, 0x23, 0x9a, 0x4e, 0x09, 0x4e, 0x7c, 0xbb,
	0x65, 0xb6, 0x6b, 0xba, 0xee, 0x52, 0x3a, 0x14, 0x28, 0x5a, 0x83, 0xca, 0xa2, 0xe0, 0x64, 0xdd,
	0x8a, 0xf5, 0xd9, 0xe5, 0x16, 0xbc, 0x0b, 0x8d, 0xa5, 0x88, 0x28, 0xba, 0x09, 0x55, 0xd1, 0x99,
	0x32, 0xa8, 0xfa, 0xf6, 0xc5, 0x37, 0xa4, 0x3e, 0x54, 0x94, 0xe0, 0x07, 0x43, 0x77, 0xed, 0xf0,
	0x49, 0x9c, 0xe3, 0xbf, 0xac, 0x6b, 0x1b, 0x25, 0x79, 0x4a, 0xb2, 0xe7, 0x24, 0x12, 0xbb, 0xf3,
	0xbe, 0xb5, 0xc3, 0xba, 0xc2, 0xba, 0xfc, 0x90, 0x1b, 0xd0, 0xd4, 0x14, 0xca, 0x3d, 0xf1, 0x2b,
	0x2d, 0xa3, 0x5d, 0xbb, 0x6b, 0x1f, 0xc6, 0x33, 0x8a, 0x43, 0xfd, 0xbb, 0x74, 0x52, 0x6b, 0x61,
	0x9f, 0xad, 0x85, 0x20, 0x0a, 0x2d, 0xc4, 0x6e, 0x67, 0x68, 0x21, 0x58, 0xa1, 0xa2, 0x04, 0x5f,
	0x1b, 0x50, 0xdb, 0x2d, 0xa6, 0xa5, 0xa8, 0x7f, 0x7d, 0x86, 0x71, 0xaa, 0xbd, 0x11, 0x18, 0x87,
	0x42, 0x06, 0x53, 0xc1, 0xc6, 0x21, 0xc7, 0x52, 0xdf, 0x6a, 0x19, 0x8b, 0x7e, 0x30, 0x52, 0x8e,
	0x51, 0x11, 0x85, 0x1e, 0x2e, 0x06, 0x45, 0x6b, 0x50, 0x15, 0x83, 0x8a, 0xfa, 0x36, 0x1f, 0x5d,
	0xa1, 0x5a, 0x71, 0xd9, 0x53, 0xc2, 0xa8, 0xc8, 0xba, 0x15, 0x8a, 0x6f, 0xe4, 0x83, 0x23, 0xc7,
	0x0d, 0xf5, 0x1d, 0x31, 0x7d, 0xf4, 0x32, 0xf8, 0x0c, 0x1a, 0xcb, 0x33, 0x04, 0x05, 0x50, 0x57,
	0x03, 0x47, 0xa4, 0x88, 0xbb, 0x6c, 0xdf, 0x35, 0xfe, 0x17, 0x82, 0x44, 0x45, 0x0a, 0xfe, 0x05,
	0xf5, 0x49, 0x99, 0xc4, 0xd1, 0x34, 0x2f, 0xa3, 0x34, 0x11, 0xfe, 0x2f, 0xca, 0x9a, 0x1b, 0x1e,
	0xe4, 0x65, 0x2f, 0x41, 0xd7, 0xa0, 0x5e, 0xc4, 0x24, 0xc9, 0xe6, 0x11, 0xc5, 0x38, 0x11, 0x11,
	0x35, 0x15, 0x0b, 0xa4, 0x61, 0x88, 0x71, 0x12, 0x7c, 0x67, 0x42, 0x7d, 0x90, 0xe3, 0x22, 0x66,
	0x59, 0xd1, 0xc5, 0x87, 0xe8, 0x12, 0xd8, 0x29, 0xc9, 0x4b, 0x26, 0x54, 0x76, 0x43, 0xb9, 0xe0,
	0xc1, 0x66, 0x25, 0xe3, 0xb0, 0x29, 0x60, 0xb5, 0x5a, 0x48, 0x6b, 0x9d, 0x92, 0xd6, 0x87, 0x8a,
	0x88, 0xa0, 0xb2, 0x6c, 0xe1, 0x08, 0x0a, 0xc0, 0x8a, 0x8b, 0xa9, 0x50, 0xad, 0xbe, 0xed, 0xe9,
	0x2c, 0xea, 0x6c, 0x85, 0xdc, 0xb8, 0x34, 0x77, 0x33, 0xa1, 0x8b, 0x5f, 0x7d, 0xfb, 0xdc, 0x55,
	0x0a, 0x5e, 0x81, 0x2a, 0x26, 0xd3, 0x94, 0x9c, 0xec, 0x2f, 0x85, 0xa1, 0x0d, 0x68, 0x4e, 0x32,
	0xc2, 0x8a, 0x6c, 0x16, 0xc9, 0x30, 0x6b, 0x22, 0x9e, 0x86, 0x02, 0x7b, 0x22, 0xda, 0x9b, 0xb0,
	0x9a, 0xd2, 0x68, 0x5a, 0xc4, 0x49, 0x8a, 0x09, 0x8b, 0xb2, 0xdc, 0x77, 0x4f, 0x54, 0x70, 0x4a,
	0x1f, 0x28, 0xdb, 0x20, 0x0f, 0xbe, 0x31, 0xa1, 0xda, 0xc7, 0x8c, 0x6b, 0x77, 0x76, 0xa1, 0x6d,
	0x80, 0x99, 0xe5, 0x42, 0xbb, 0xa5, 0xc2, 0x5d, 0x92, 0x3d, 0x34, 0xb3, 0x7c, 0x21, 0x99, 0x75,
	0x4a, 0xb2, 0xeb, 0x50, 0x27, 0xe5, 0x3c, 0x7a, 0x9e, 0x15, 0x4f, 0x71, 0x21, 0x2b, 0xd1, 0xee,
	0x54, 0x39, 0xc1, 0x37, 0x42, 0x20, 0xe5, 0xfc, 0x63, 0x69, 0x39, 0xad, 0x9b, 0xfd, 0xa7, 0x75,
	0x53, 0x69, 0xa9, 0x9e, 0x97, 0x96, 0x6b, 0xb0, 0x8a, 0x5f, 0x30, 0x5c, 0x90, 0x58, 0xcb, 0xe7,
	0x08, 0xf9, 0x9a, 0x1a, 0x95, 0xfa, 0x5d, 0x87, 0x0b, 0x0b, 0x9a, 0x2a, 0x1b, 0x29, 0xf3, 0xe2,
	0xef, 0x81, 0x40, 0x83, 0x1f, 0x2d, 0x68, 0xee, 0xbd, 0xc0, 0x93, 0x92, 0x7b, 0x30, 0x64, 0x38,
	0x3f, 0x47, 0xc2, 0xff, 0x82, 0x43, 0xcb, 0x31, 0x65, 0x58, 0xeb, 0xf8, 0x37, 0xed, 0xe3, 0x89,
	0x1d, 0x42, 0xcd, 0xe2, 0x4d, 0x47, 0x30, 0xe3, 0x9a, 0x89, 0x21, 0xe5, 0x86, 0x7a, 0x89, 0xae,
	0x42, 0x8d, 0xcb, 0x99, 0x32, 0x5c, 0x08, 0x2d, 0x75, 0xa7, 0x3b, 0xa4, 0x9c, 0xf7, 0x18, 0x2e,
	0xd0, 0x16, 0x78, 0x93, 0x82, 0x9b, 0xd3, 0x38, 0xd2, 0x7b, 0xc8, 0x09, 0xa5, 0x45, 0xbf, 0xa0,
	0xed, 0x7d, 0xb5, 0xe7, 0x1d, 0xb8, 0x38, 0xc9, 0xc8, 0xa4, 0x2c, 0x0a, 0x5e, 0x32, 0xca, 0x07,
	0x2a, 0xea, 0x56, 0xdf, 0x0c, 0xe8, 0x98, 0x30, 0x54, 0x76, 0xb4, 0x01, 0x50, 0xe0, 0x3c, 0x2b,
	0x18, 0x3f, 0xe7, 0x44, 0xc5, 0xba, 0x12, 0xef, 0x63, 0x86, 0xfe, 0x03, 0x17, 0x14, 0x29, 0x25,
	0x0c, 0x17, 0xcf, 0x62, 0xf9, 0x0e, 0xd1, 0x4d, 0xbf, 0x2a, 0x8d, 0x3d, 0x65, 0x43, 0x9b, 0xe0,
	0xd1, 0x27, 0x59, 0x39, 0x4b, 0x22, 0xca, 0xb2, 0x3c, 0x1a, 0xcf, 0xb2, 0xb1, 0x28, 0x60, 0xbd,
	0xf3, 0xaa, 0xb4, 0x0e, 0x59, 0x96, 0x77, 0x66, 0xd9, 0x98, 0x5f, 0x65, 0x19, 0x99, 0x1d, 0x45,
	0x19, 0x99, 0x60, 0x1f, 0x96, 0x1c, 0xae, 0x71, 0x78, 0x40, 0x26, 0x18, 0xfd, 0x1b, 0x1a, 0x45,
	0x49, 0x22, 0xfc, 0x0c, 0x17, 0x47, 0xd1, 0x9c, 0x8a, 0x97, 0x88, 0xb5, 0x98, 0x26, 0x25, 0xd9,
	0xe3, 0x86, 0x87, 0x34, 0xf8, 0xdc, 0x00, 0xe7, 0xd1, 0x2c, 0x26, 0xe7, 0x77, 0x43, 0xfb, 0x38,
	0x33, 0x32, 0x95, 0xab, 0x3a, 0x95, 0xb2, 0x91, 0x8e, 0x33, 0xf5, 0x1e, 0x2f, 0x38, 0x95, 0xdd,
	0x48, 0xe4, 0xde, 0x3a, 0x2f, 0xf7, 0x4d, 0xbc, 0xbc, 0x0c, 0xbe, 0x35, 0xc0, 0xe5, 0x11, 0xca,
	0xf7, 0xc1, 0xd9, 0xfe, 0xe8, 0xc6, 0x33, 0x4f, 0x35, 0xde, 0x4d, 0xa8, 0x32, 0x71, 0xbd, 0x88,
	0xa6, 0x3c, 0xeb, 0x02, 0x96, 0x14, 0xb4, 0x0e, 0x0e, 0x1f, 0x23, 0xfc, 0xa5, 0xb6, 0x7c, 0x57,
	0x68, 0x10, 0x6d, 0x82, 0xf3, 0x89, 0xda, 0xed, 0x0f, 0x6d, 0xb9, 0xfc, 0x8e, 0x09, 0x35, 0x29,
	0xf8, 0x14, 0x9a, 0xdd, 0x4e, 0x88, 0xe3, 0x04, 0x17, 0x6f, 0x8b, 0xe0, 0x0a, 0x54, 0x69, 0x56,
	0x16, 0x93, 0x93, 0x31, 0x28, 0x0c, 0xfd, 0x03, 0x9c, 0x64, 0x1c, 0x9d, 0x9a, 0x2d, 0xd5, 0x64,
	0x2c, 0xee, 0x93, 0x35, 0xb0, 0x9e, 0xe2, 0xa3, 0x13, 0x93, 0x9a, 0x03, 0x37, 0x76, 0x01, 0xba,
	0xc7, 0xb7, 0x8e, 0x03, 0xd6, 0xbd, 0x47, 0x07, 0xde, 0x0a, 0x7f, 0xbd, 0xdd, 0x3b, 0xe8, 0xee,
	0x7a, 0x06, 0x7f, 0x8e, 0x3d, 0xfc, 0x70, 0xbf, 0xdb, 0xef, 0x7b, 0x26, 0xba, 0x04, 0xcd, 0x41,
	0x7f, 0xff, 0x71, 0x74, 0x7f, 0x10, 0x46, 0xa3, 0xbd, 0xe1, 0xc8, 0xfb, 0xfe, 0xd5, 0x6f, 0x6e,
	0xc7, 0x7b, 0xf9, 0x7a, 0xdd, 0xf8, 0xe9, 0xf5, 0xba, 0xf1, 0xcb, 0xeb, 0x75, 0xe3, 0x8b, 0x5f,
	0xd7, 0x57, 0x7e, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xb4, 0x08, 0x10, 0x03, 0x72, 0x0c, 0x00, 0x00,
}
